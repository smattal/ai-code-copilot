import { ModelResponse, ModelConfig, Fix } from '../types/model';
import { logger } from '../utils/logger';

export interface ModelRouterConfig {
  maxInputLength: number;  // Maximum input length for each model
  maxLatency: number;     // Maximum acceptable latency in ms
  maxCost: number;        // Maximum cost per request in cents
}

export interface AIModel {
  name: string;
  maxInputLength: number;
  averageLatency: number;
  costPerRequest: number;
  isAvailable: boolean;
  generateSuggestion(input: string): Promise<ModelResponse>;
}

export class ModelRouter {
  private models: AIModel[];
  private config: ModelRouterConfig;
  
  constructor(config: ModelRouterConfig) {
    this.config = config;
    this.models = [
      {
        name: 'gpt4',
        maxInputLength: 100000,
        averageLatency: 2000,
        costPerRequest: 10,
        isAvailable: true,
        generateSuggestion: this.gpt4Handler.bind(this)
      },
      {
        name: 'gpt35',
        maxInputLength: 16000,
        averageLatency: 500,
        costPerRequest: 1,
        isAvailable: true,
        generateSuggestion: this.gpt35Handler.bind(this)
      },
      {
        name: 'mockModel',
        maxInputLength: Infinity,
        averageLatency: 100,
        costPerRequest: 0,
        isAvailable: true,
        generateSuggestion: this.mockModelHandler.bind(this)
      }
    ];
  }

  async routeRequest(input: string, modelConfig?: ModelConfig): Promise<ModelResponse> {
    const inputLength = input.length;
    
    // Filter models based on constraints
    const eligibleModels = this.models.filter(model => 
      model.isAvailable &&
      model.maxInputLength >= inputLength &&
      model.averageLatency <= (modelConfig?.maxLatency ?? this.config.maxLatency) &&
      model.costPerRequest <= (modelConfig?.maxCost ?? this.config.maxCost)
    );

    if (eligibleModels.length === 0) {
      // Fallback to rule-based handling if no models are available
      return this.ruleBasedFallback(input);
    }

    // Sort by preference (cost, then latency)
    eligibleModels.sort((a, b) => {
      if (a.costPerRequest !== b.costPerRequest) {
        return a.costPerRequest - b.costPerRequest;
      }
      return a.averageLatency - b.averageLatency;
    });

    // Try models in order until one succeeds
    for (const model of eligibleModels) {
      try {
        return await model.generateSuggestion(input);
      } catch (error) {
        logger.warning(`Model ${model.name} failed: ${error}`);
        continue;
      }
    }

    // If all models fail, use rule-based fallback
    return this.ruleBasedFallback(input);
  }

  private async gpt4Handler(input: string): Promise<ModelResponse> {
    // TODO: Implement actual GPT-4 API call
    throw new Error('GPT-4 implementation pending');
  }

  private async gpt35Handler(input: string): Promise<ModelResponse> {
    // TODO: Implement actual GPT-3.5 API call
    throw new Error('GPT-3.5 implementation pending');
  }

  private async mockModelHandler(input: string): Promise<ModelResponse> {
    // Simple mock model for testing
    return {
      suggestion: 'Mock suggestion based on rule-based analysis',
      confidence: 0.7,
      model: 'mock',
      reasoning: 'Generated by mock model using basic pattern matching'
    };
  }

  private ruleBasedFallback(input: string): ModelResponse {
    // Basic rule-based fixes
    const fixes: Fix[] = [
      {
        pattern: /<img[^>]+>/i,
        fix: (match: string) => match.includes('alt=') ? match : match.replace('>', ' alt="Image" >'),
        reasoning: 'Added missing alt attribute for accessibility'
      },
      {
        pattern: /<a[^>]+target="_blank"[^>]*>/i,
        fix: (match: string) => match.includes('rel="noopener noreferrer"') ? match : match.replace('>', ' rel="noopener noreferrer">'),
        reasoning: 'Added security attributes for _blank links'
      },
      {
        pattern: /<html[^>]*>/i,
        fix: (match: string) => match.includes('lang=') ? match : match.replace('>', ' lang="en">'),
        reasoning: 'Added missing language attribute'
      }
    ];

    // Apply rule-based fixes
    for (const rule of fixes) {
      if (rule.pattern.test(input)) {
        const fixedContent = input.replace(rule.pattern, rule.fix);
        return {
          suggestion: fixedContent,
          confidence: 0.9,
          model: 'rule-based',
          reasoning: rule.reasoning
        };
      }
    }

    return {
      suggestion: input,
      confidence: 0,
      model: 'rule-based',
      reasoning: 'No applicable rules found'
    };
  }
}